/*!
Waypoints - 4.0.1
Copyright © 2011-2016 Caleb Troughton
Licenciado bajo la licencia MIT.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/
(función () {
  'uso estricto'

  var keyCounter = 0
  var allWaypoints = {}

  /* http://imakewebthings.com/waypoints/api/waypoint */
  función Waypoint (opciones) {
    if (! options) {
      lanzar un nuevo error ('No se pasaron opciones al constructor de Waypoint')
    }
    if (! options.element) {
      lanzar un nuevo error ('No se pasó ninguna opción de elemento al constructor de Waypoint')
    }
    if (! options.handler) {
      lanzar un nuevo Error ('No se pasó ninguna opción de controlador al constructor de Waypoint')
    }

    this.key = 'waypoint-' + keyCounter
    this.options = Waypoint.Adapter.extend ({}, Waypoint.defaults, opciones)
    this.element = this.options.element
    this.adapter = nuevo Waypoint.Adapter (this.element)
    this.callback = options.handler
    this.axis = this.options.horizontal? 'horizontal Vertical'
    this.enabled = this.options.enabled
    this.triggerPoint = null
    this.group = Waypoint.Group.findOrCreate ({
      nombre: this.options.group,
      eje: this.axis
    })
    this.context = Waypoint.Context.findOrCreateByElement (this.options.context)

    if (Waypoint.offsetAliases [this.options.offset]) {
      this.options.offset = Waypoint.offsetAliases [this.options.offset]
    }
    this.group.add (esto)
    this.context.add (esto)
    allWaypoints [this.key] = esto
    keyCounter + = 1
  }

  /* Privado */
  Waypoint.prototype.queueTrigger = función (dirección) {
    this.group.queueTrigger (esto, dirección)
  }

  / * Privado * /
  Waypoint.prototype.trigger = function (args) {
    if (! this.enabled) {
      regreso
    }
    if (this.callback) {
      this.callback.apply (this, args)
    }
  }

  / * Público * /
  / * http://imakewebthings.com/waypoints/api/destroy * /
  Waypoint.prototype.destroy = function () {
    this.context.remove (esto)
    this.group.remove (esto)
    eliminar todos losWaypoints [this.key]
  }

  / * Público * /
  / * http://imakewebthings.com/waypoints/api/disable * /
  Waypoint.prototype.disable = function () {
    this.enabled = falso
    devuelve esto
  }

  / * Público * /
  / * http://imakewebthings.com/waypoints/api/enable * /
  Waypoint.prototype.enable = function () {
    this.context.refresh ()
    this.enabled = true
    devuelve esto
  }

  / * Público * /
  / * http://imakewebthings.com/waypoints/api/next * /
  Waypoint.prototype.next = function () {
    devuelve this.group.next (esto)
  }

  / * Público * /
  / * http://imakewebthings.com/waypoints/api/previous * /
  Waypoint.prototype.previous = function () {
    devuelve this.group.previous (esto)
  }

  / * Privado * /
  Waypoint.invokeAll = function (método) {
    var allWaypointsArray = []
    para (var waypointKey en todos losWaypoints) {
      allWaypointsArray.push (allWaypoints [waypointKey])
    }
    for (var i = 0, end = allWaypointsArray.length; i <end; i ++) {
      allWaypointsArray [i] [método] ()
    }
  }

  / * Público * /
  / * http://imakewebthings.com/waypoints/api/destroy-all * /
  Waypoint.destroyAll = function () {
    Waypoint.invokeAll ('destruir')
  }

  / * Público * /
  / * http://imakewebthings.com/waypoints/api/disable-all * /
  Waypoint.disableAll = function () {
    Waypoint.invokeAll ('deshabilitar')
  }

  / * Público * /
  / * http://imakewebthings.com/waypoints/api/enable-all * /
  Waypoint.enableAll = function () {
    Waypoint.Context.refreshAll ()
    para (var waypointKey en todos losWaypoints) {
      allWaypoints [waypointKey] .enabled = true
    }
    devuelve esto
  }

  / * Público * /
  / * http://imakewebthings.com/waypoints/api/refresh-all * /
  Waypoint.refreshAll = function () {
    Waypoint.Context.refreshAll ()
  }

  / * Público * /
  / * http://imakewebthings.com/waypoints/api/viewport-height * /
  Waypoint.viewportHeight = function () {
    return window.innerHeight || document.documentElement.clientHeight
  }

  / * Público * /
  / * http://imakewebthings.com/waypoints/api/viewport-width * /
  Waypoint.viewportWidth = function () {
    return document.documentElement.clientWidth
  }

  Waypoint.adapters = []

  Waypoint.defaults = {
    contexto: ventana,
    continuo: verdadero,
    habilitado: verdadero,
    grupo: 'predeterminado',
    horizontal: falso,
    desplazamiento: 0
  }

  Waypoint.offsetAliases = {
    'bottom-in-view': function () {
      devuelve this.context.innerHeight () - this.adapter.outerHeight ()
    },
    'derecha a la vista': function () {
      devuelve this.context.innerWidth () - this.adapter.outerWidth ()
    }
  }

  window.Waypoint = Waypoint
} ())
; (función () {
  'uso estricto'

  function requestAnimationFrameShim (devolución de llamada) {
    window.setTimeout (devolución de llamada, 1000/60)
  }

  var keyCounter = 0
  var contextos = {}
  var Waypoint = ventana.Waypoint
  var oldWindowLoad = window.onload

  / * http://imakewebthings.com/waypoints/api/context * /
  función Contexto (elemento) {
    this.element = elemento
    this.Adapter = Waypoint.Adapter
    this.adapter = nuevo this.Adapter (elemento)
    this.key = 'waypoint-context-' + keyCounter
    this.didScroll = falso
    this.didResize = falso
    this.oldScroll = {
      x: this.adapter.scrollLeft (),
      y: this.adapter.scrollTop ()
    }
    this.waypoints = {
      vertical: {},
      horizontal: {}
    }

    element.waypointContextKey = this.key
    contextos [element.waypointContextKey] = esto
    keyCounter + = 1
    if (! Waypoint.windowContext) {
      Waypoint.windowContext = verdadero
      Waypoint.windowContext = nuevo contexto (ventana)
    }

    this.createThrottledScrollHandler ()
    this.createThrottledResizeHandler ()
  }

  / * Privado * /
  Context.prototype.add = function (waypoint) {
    var axis = waypoint.options.horizontal? 'horizontal Vertical'
    this.waypoints [eje] [waypoint.key] = waypoint
    this.refresh ()
  }

  / * Privado * /
  Context.prototype.checkEmpty = function () {
    var horizontalEmpty = this.Adapter.isEmptyObject (this.waypoints.horizontal)
    var verticalEmpty = this.Adapter.isEmptyObject (this.waypoints.vertical)
    var isWindow = this.element == this.element.window
    if (horizontalEmpty && verticalEmpty &&! isWindow) {
      this.adapter.off ('. waypoints')
      eliminar contextos [this.key]
    }
  }

  / * Privado * /
  Context.prototype.createThrottledResizeHandler = function () {
    var self = esto

    function resizeHandler () {
      self.handleResize ()
      self.didResize = falso
    }

    this.adapter.on ('resize.waypoints', function () {
      if (! self.didResize) {
        self.didResize = verdadero
        Waypoint.requestAnimationFrame (resizeHandler)
      }
    })
  }

  / * Privado * /
  Context.prototype.createThrottledScrollHandler = function () {
    var self = esto
    function scrollHandler () {
      self.handleScroll ()
      self.didScroll = falso
    }

    this.adapter.on ('scroll.waypoints', function () {
      if (! self.didScroll || Waypoint.isTouch) {
        self.didScroll = verdadero
        Waypoint.requestAnimationFrame (scrollHandler)
      }
    })
  }

  / * Privado * /
  Context.prototype.handleResize = function () {
    Waypoint.Context.refreshAll ()
  }

  / * Privado * /
  Context.prototype.handleScroll = function () {
    var triggeredGroups = {}
    var ejes = {
      horizontal: {
        newScroll: this.adapter.scrollLeft (),
        oldScroll: this.oldScroll.x,
        adelante: 'derecha',
        al revés: 'izquierda'
      },
      vertical: {
        newScroll: this.adapter.scrollTop (),
        oldScroll: this.oldScroll.y,
        adelante: 'abajo',
        al revés: 'arriba'
      }
    }

    para (var axisKey en ejes) {
      var axis = axes [axisKey]
      var isForward = axis.newScroll> axis.oldScroll
      var direction = isForward? axis.forward: axis.backward

      para (var waypointKey en this.waypoints [axisKey]) {
        var waypoint = this.waypoints [axisKey] [waypointKey]
        if (waypoint.triggerPoint === null) {
          Seguir
        }
        var wasBeforeTriggerPoint = axis.oldScroll <waypoint.triggerPoint
        var nowAfterTriggerPoint = axis.newScroll> = waypoint.triggerPoint
        var crossForward = wasBeforeTriggerPoint && nowAfterTriggerPoint
        var crossingBackward =! wasBeforeTriggerPoint &&! nowAfterTriggerPoint
        if (cruzado hacia adelante || cruzado hacia atrás) {
          waypoint.queueTrigger (dirección)
          triggeredGroups [waypoint.group.id] = waypoint.group
        }
      }
    }

    para (var groupKey en triggeredGroups) {
      triggeredGroups [groupKey] .flushTriggers ()
    }

    this.oldScroll = {
      x: axes.horizontal.newScroll,
      y: axes.vertical.newScroll
    }
  }

  / * Privado * /
  Context.prototype.innerHeight = function () {
    / * eslint-deshabilitar eqeqeq * /
    if (this.element == this.element.window) {
      return Waypoint.viewportHeight ()
    }
    / * eslint-enable eqeqeq * /
    devuelve this.adapter.innerHeight ()
  }

  / * Privado * /
  Context.prototype.remove = function (waypoint) {
    eliminar this.waypoints [waypoint.axis] [waypoint.key]
    this.checkEmpty ()
  }

  / * Privado * /
  Context.prototype.innerWidth = function () {
    / * eslint-deshabilitar eqeqeq * /
    if (this.element == this.element.window) {
      return Waypoint.viewportWidth ()
    }
    / * eslint-enable eqeqeq * /
    devuelve this.adapter.innerWidth ()
  }

  / * Público * /
  / * http://imakewebthings.com/waypoints/api/context-destroy * /
  Context.prototype.destroy = function () {
    var allWaypoints = []
    para (eje var en this.waypoints) {
      para (var waypointKey en this.waypoints [eje]) {
        allWaypoints.push (this.waypoints [eje] [waypointKey])
      }
    }
    for (var i = 0, end = allWaypoints.length; i <end; i ++) {
      allWaypoints [i] .destroy ()
    }
  }

  / * Público * /
  / * http://imakewebthings.com/waypoints/api/context-refresh * /
  Context.prototype.refresh = function () {
    / * eslint-deshabilitar eqeqeq * /
    var isWindow = this.element == this.element.window
    / * eslint-enable eqeqeq * /
    var contextOffset = isWindow? indefinido: this.adapter.offset ()
    var triggeredGroups = {}
    var ejes

    this.handleScroll ()
    ejes = {
      horizontal: {
        contextOffset: isWindow? 0: contextOffset.left,
        contextScroll: isWindow? 0: this.oldScroll.x,
        contextDimension: this.innerWidth (),
        oldScroll: this.oldScroll.x,
        adelante: 'derecha',
        al revés: 'izquierda',
        offsetProp: 'izquierda'
      },
      vertical: {
        contextOffset: isWindow? 0: contextOffset.top,
        contextScroll: isWindow? 0: this.oldScroll.y,
        contextDimension: this.innerHeight (),
        oldScroll: this.oldScroll.y,
        adelante: 'abajo',
        al revés: 'arriba',
        offsetProp: 'top'
      }
    }

    para (var axisKey en ejes) {
      var axis = axes [axisKey]
      para (var waypointKey en this.waypoints [axisKey]) {
        var waypoint = this.waypoints [axisKey] [waypointKey]
        ajuste var = waypoint.options.offset
        var oldTriggerPoint = waypoint.triggerPoint
        var elementOffset = 0
        var freshWaypoint = oldTriggerPoint == null
        var contextModifier, wasBeforeScroll, nowAfterScroll
        var triggeredBackward, triggeredForward

        if (waypoint.element! == waypoint.element.window) {
          elementOffset = waypoint.adapter.offset () [axis.offsetProp]
        }

        if (tipo de ajuste === 'función') {
          ajuste = ajuste.apply (waypoint)
        }
        else if (tipo de ajuste === 'cadena') {
          ajuste = parseFloat (ajuste)
          if (waypoint.options.offset.indexOf ('%')> - 1) {
            ajuste = Math.ceil (axis.contextDimension * ajuste / 100)
          }
        }

        contextModifier = axis.contextScroll - axis.contextOffset
        waypoint.triggerPoint = Math.floor (elementOffset + contextModifier - ajuste)
        wasBeforeScroll = oldTriggerPoint <axis.oldScroll
        nowAfterScroll = waypoint.triggerPoint> = axis.oldScroll
        triggeredBackward = wasBeforeScroll && nowAfterScroll
        triggeredForward =! wasBeforeScroll &&! nowAfterScroll

        if (! freshWaypoint && triggeredBackward) {
          waypoint.queueTrigger (eje.hacia atrás)
          triggeredGroups [waypoint.group.id] = waypoint.group
        }
        else if (! freshWaypoint && triggeredForward) {
          waypoint.queueTrigger (axis.forward)
          triggeredGroups [waypoint.group.id] = waypoint.group
        }
        else if (freshWaypoint && axis.oldScroll> = waypoint.triggerPoint) {
          waypoint.queueTrigger (axis.forward)
          triggeredGroups [waypoint.group.id] = waypoint.group
        }
      }
    }

    Waypoint.requestAnimationFrame (function () {
      para (var groupKey en triggeredGroups) {
        triggeredGroups [groupKey] .flushTriggers ()
      }
    })

    devuelve esto
  }

  / * Privado * /
  Context.findOrCreateByElement = función (elemento) {
    return Context.findByElement (elemento) || nuevo contexto (elemento)
  }

  / * Privado * /
  Context.refreshAll = function () {
    para (var contextId en contextos) {
      contextos [contextId] .refresh ()
    }
  }

  / * Público * /
  / * http://imakewebthings.com/waypoints/api/context-find-by-element * /
  Context.findByElement = function (element) {
    devolver contextos [element.waypointContextKey]
  }

  window.onload = function () {
    if (oldWindowLoad) {
      oldWindowLoad ()
    }
    Context.refreshAll ()
  }


  Waypoint.requestAnimationFrame = function (callback) {
    var requestFn = window.requestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      requestAnimationFrameShim
    requestFn.call (ventana, devolución de llamada)
  }
  Waypoint.Context = Contexto
} ())
; (función () {
  'uso estricto'

  función byTriggerPoint (a, b) {
    devolver a.triggerPoint - b.triggerPoint
  }

  función byReverseTriggerPoint (a, b) {
    return b.triggerPoint - a.triggerPoint
  }

  var grupos = {
    vertical: {},
    horizontal: {}
  }
  var Waypoint = ventana.Waypoint

  / * http://imakewebthings.com/waypoints/api/group * /
  grupo de funciones (opciones) {
    this.name = options.name
    this.axis = options.axis
    this.id = this.name + '-' + this.axis
    this.waypoints = []
    this.clearTriggerQueues ()
    grupos [this.axis] [this.name] = this
  }

  / * Privado * /
  Group.prototype.add = function (waypoint) {
    this.waypoints.push (punto de ruta)
  }

  / * Privado * /
  Group.prototype.clearTriggerQueues = function () {
    this.triggerQueues = {
      arriba: [],
      abajo: [],
      izquierda: [],
      derecho: []
    }
  }

  / * Privado * /
  Group.prototype.flushTriggers = function () {
    para (dirección var en this.triggerQueues) {
      var waypoints = this.triggerQueues [dirección]
      var reverse = direction === 'arriba' || dirección === 'izquierda'
      waypoints.sort (inverso? byReverseTriggerPoint: byTriggerPoint)
      for (var i = 0, end = waypoints.length; i <end; i + = 1) {
        var waypoint = waypoints [i]
        if (waypoint.options.continuous || i === waypoints.length - 1) {
          waypoint.trigger ([dirección])
        }
      }
    }
    this.clearTriggerQueues ()
  }

  / * Privado * /
  Group.prototype.next = function (waypoint) {
    this.waypoints.sort (porTriggerPoint)
    var index = Waypoint.Adapter.inArray (waypoint, this.waypoints)
    var isLast = index === this.waypoints.length - 1
    el regreso es el último? nulo: this.waypoints [índice + 1]
  }

  / * Privado * /
  Group.prototype.previous = function (waypoint) {
    this.waypoints.sort (porTriggerPoint)
    var index = Waypoint.Adapter.inArray (waypoint, this.waypoints)
    índice de retorno? this.waypoints [índice - 1]: nulo
  }

  / * Privado * /
  Group.prototype.queueTrigger = function (waypoint, direction) {
    this.triggerQueues [dirección] .push (waypoint)
  }

  / * Privado * /
  Group.prototype.remove = function (waypoint) {
    var index = Waypoint.Adapter.inArray (waypoint, this.waypoints)
    if (índice> -1) {
      this.waypoints.splice (índice, 1)
    }
  }

  / * Público * /
  / * http://imakewebthings.com/waypoints/api/first * /
  Group.prototype.first = function () {
    devuelve this.waypoints [0]
  }

  / * Público * /
  / * http://imakewebthings.com/waypoints/api/last * /
  Group.prototype.last = function () {
    devuelve this.waypoints [this.waypoints.length - 1]
  }

  / * Privado * /
  Group.findOrCreate = function (opciones) {
    grupos de retorno [options.axis] [options.name] || nuevo grupo (opciones)
  }

  Waypoint.Group = Grupo
} ())
; (función () {
  'uso estricto'

  var $ = window.jQuery
  var Waypoint = ventana.Waypoint

  function JQueryAdapter (elemento) {
    this. $ elemento = $ (elemento)
  }

  $ .each ([
    'innerHeight',
    'innerWidth',
    'apagado',
    'compensar',
    'en',
    'exteriorHeight',
    'externalWidth',
    'scrollLeft',
    'scrollTop'
  ], función (i, método) {
    JQueryAdapter.prototype [método] = function () {
      var args = Array.prototype.slice.call (argumentos)
      devuelve este. $ elemento [método] .apply (este. $ elemento, argumentos)
    }
  })

  $ .each ([
    'ampliar',
    'inArray',
    'isEmptyObject'
  ], función (i, método) {
    JQueryAdapter [método] = $ [método]
  })

  Waypoint.adapters.push ({
    nombre: 'jquery',
    Adaptador: JQueryAdapter
  })
  Waypoint.Adapter = JQueryAdapter
} ())
; (función () {
  'uso estricto'

  var Waypoint = ventana.Waypoint

  function createExtension (framework) {
    función de retorno () {
      var waypoints = []
      var anula = argumentos [0]

      if (framework.isFunction (argumentos [0])) {
        overrides = framework.extend ({}, argumentos [1])
        overrides.handler = argumentos [0]
      }

      this.each (function () {
        var options = framework.extend ({}, overrides, {
          elemento: este
        })
        if (typeof options.context === 'string') {
          options.context = framework (esto) .closest (options.context) [0]
        }
        waypoints.push (nuevo Waypoint (opciones))
      })

      volver waypoints
    }
  }

  if (window.jQuery) {
    window.jQuery.fn.waypoint = createExtension (window.jQuery)
  }
  if (window.Zepto) {
    window.Zepto.fn.waypoint = createExtension (window.Zepto)
  }
} ())
;